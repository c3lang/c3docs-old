<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Types - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Types";
    var mkdocs_page_input_path = "types.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Types</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#naming">Naming</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#differences-from-c">Differences from C</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#basic-types">Basic types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#integer-types">Integer types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integer-arithmetics">Integer arithmetics</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#integer-constants">Integer constants</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#twocc-fourcc-and-eightcc">TwoCC, FourCC and EightCC</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#base64-and-hex-data-literals">Base64 and hex data literals</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#string-literals-and-raw-strings">String literals, and raw strings</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#floating-point-types">Floating point types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#floating-point-constants">Floating point constants</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#c-compatibility">C compatibility</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#other-built-in-types">Other built-in types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pointer-types">Pointer types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-typeid-type">The typeid type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-variant-type">The variant type</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#array-types">Array types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#vector-types">Vector types</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#types-created-using-defined">Types created using defined</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#typedef">"typedef"</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#function-pointer-types">Function pointer types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#distinct-types">Distinct types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#generic-types">Generic types</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#enum">Enum</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#enum-type-inference">Enum type inference</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#enum-associated-values">Enum associated values</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#faults">Faults</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#optional-result-types">Optional Result Types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#struct-types">Struct types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#struct-subtyping">Struct subtyping</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#union-types">Union types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#nested-sub-structs-unions">Nested sub-structs / unions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#bitstructs">Bitstructs</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../errorhandling/">Errors</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtins/">Builtins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../contracts/">Contracts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../operators/">Operator overloading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../libraries/">Libraries</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../standard_library/">Standard Library</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">Crazy ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../asm/">Inline asm</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Types</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="types">Types</h1>
<p>As usual, types are divided into basic types and user defined types (enum, union, struct, faults, aliases). All types are defined on a global level. Using the <code>public</code> prefix is necessary for any type that is to be exposed outside of the current module.</p>
<h5 id="naming">Naming</h5>
<p>All user defined types in C3 starts with upper case. So <code>MyStruct</code> or <code>Mystruct</code> would be fine, <code>mystruct_t</code> or <code>mystruct</code> would not.
This naming requirement ensures that the language is easy to parse for tools.
It is possible to use attributes to change the external name of a type:</p>
<pre><code>struct Stat @extname(&quot;stat&quot;)
{
    // ...
} 

fn CInt stat(const char* pathname, Stat* buf);
</code></pre>
<p>This would for example affect generated C headers.</p>
<h5 id="differences-from-c">Differences from C</h5>
<p>Unlike C, C3 does not use type qualifiers. <code>const</code> exists, 
but is a storage class modifier, not a type qualifier. 
Instead of <code>volatile</code>, volatile loads and stores are used. 
In order to signal restrictions on parameter usage, parameter <a href="../preconditions/">preconditions</a> are used.
Instead of <code>typedef</code>, C3 uses a more general <code>define</code> construct, which also
supports distinct types.</p>
<p>C3 also requires all function pointers to be used with an alias, so:</p>
<pre><code>define Callback = fn void();
Callback a = null; // Ok!
fn Callback getCallback() { ... } // Ok!

// fn fn void() getCallback() { ... } - ERROR!
// fn void() a = null; - ERROR!```
</code></pre>
<h2 id="basic-types">Basic types</h2>
<p>Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.</p>
<h5 id="integer-types">Integer types</h5>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">bit size</th>
<th align="center">signed</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">bool*</td>
<td align="right">1</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">ichar</td>
<td align="right">8</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">char</td>
<td align="right">8</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">short</td>
<td align="right">16</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">ushort</td>
<td align="right">16</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">int</td>
<td align="right">32</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">uint</td>
<td align="right">32</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">long</td>
<td align="right">64</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">ulong</td>
<td align="right">64</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">iptr**</td>
<td align="right">varies</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">uptr**</td>
<td align="right">varies</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left">isz**</td>
<td align="right">varies</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left">usz**</td>
<td align="right">varies</td>
<td align="center">no</td>
</tr>
</tbody>
</table>
<p>* <code>bool</code> will be stored as a byte.<br />
** size, pointer and pointer sized types depend on platform.</p>
<h5 id="integer-arithmetics">Integer arithmetics</h5>
<p>All signed integer arithmetics uses 2's complement.</p>
<h5 id="integer-constants">Integer constants</h5>
<p>Integer constants are 1293832 or -918212. Without a suffix, suffix type is assumed to the signed integer of <em>arithmetic promotion width</em>. Adding the <code>u</code> suffix gives a unsigned integer of the same width. Use <code>ixx</code> and <code>uxx</code> – where <code>xx</code> is the bitwidth for typed integers, e.g. <code>1234u16</code></p>
<p>Integers may be written in decimal, but also</p>
<ul>
<li>in binary with the prefix 0b e.g. <code>0b0101000111011</code>, <code>0b011</code></li>
<li>in octal with the prefix 0o e.g. <code>0o0770</code>, <code>0o12345670</code></li>
<li>in hexadecimal with the prefix 0x e.g. <code>0xdeadbeef</code> <code>0x7f7f7f</code></li>
</ul>
<p>Furthermore, underscore <code>_</code> may be used to add space between digits to improve readability e.g. <code>0xFFFF_1234_4511_0000</code>, <code>123_000_101_100</code></p>
<h5 id="twocc-fourcc-and-eightcc">TwoCC, FourCC and EightCC</h5>
<p><a href="https://en.wikipedia.org/wiki/FourCC">FourCC</a> codes are often used to identify binary format types. C3 adds direct support for 4 character codes, but also 2 and 8 characters:</p>
<ul>
<li>2 character strings, e.g. <code>'C3'</code>, would convert to an ushort or short.</li>
<li>4 character strings, e.g. <code>'TEST'</code>, converts to an uint or int. </li>
<li>8 character strings, e.g. <code>'FOOBAR11'</code> converts to an ulong or long.</li>
</ul>
<p>Conversion is always done so that the character string has the correct ordering in memory. This means that the same characters may have different integer values on different architectures due to endianess.</p>
<h5 id="base64-and-hex-data-literals">Base64 and hex data literals</h5>
<p>Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format <code>b64'&lt;base64&gt;'</code>. Hex encoded values work as base64 but with the format <code>x'&lt;hex&gt;'</code>. In data literals any whitespace is ignored, so <code>'00 00 11'x</code> encodes to the same value as <code>x'000011'</code>.</p>
<p>In our case we could encode <code>b64'Rk9PQkFSMTE='</code> as <code>'FOOBAR11'</code>.</p>
<p>Base64 and hex data literals initializes to arrays of the char type:</p>
<pre><code>char[*] hello_world_base64 = b64&quot;SGVsbG8gV29ybGQh&quot;;
char[*] hello_world_hex = x&quot;4865 6c6c 6f20 776f 726c 6421&quot;;
</code></pre>
<h5 id="string-literals-and-raw-strings">String literals, and raw strings</h5>
<p>Regular string literals is text enclosed in <code>" ... "</code> just like in C. C3 also offers two other types of literals: <em>multi-line strings</em> and <em>raw strings</em>.</p>
<p>Raw strings uses text between ` `. Inside of a raw string, no escapes are available. To write a ` double the character:</p>
<pre><code>char* foo = `C:\foo\bar.dll`;
char* bar = `&quot;Say ``hello``&quot;`;
// Same as
char* foo = &quot;C:\\foo\\bar.dll&quot;;
char* bar = &quot;\&quot;Say `hello`\&quot;&quot;;
</code></pre>
<h5 id="floating-point-types">Floating point types</h5>
<table>
<thead>
<tr>
<th>Name</th>
<th align="right">bit size</th>
</tr>
</thead>
<tbody>
<tr>
<td>float16*</td>
<td align="right">16</td>
</tr>
<tr>
<td>float</td>
<td align="right">32</td>
</tr>
<tr>
<td>double</td>
<td align="right">64</td>
</tr>
<tr>
<td>float128*</td>
<td align="right">128</td>
</tr>
</tbody>
</table>
<p>*support depends on platform</p>
<h5 id="floating-point-constants">Floating point constants</h5>
<p>Floating point constants will <em>at least</em> use 64 bit precision. Just like for integer constants, it is allowed to use underscore, but it may not occur immediately before or after a dot or an exponential.</p>
<p>Floating point values may be written in decimal or hexadecimal. For decimal, the exponential symbol is e (or E, both are acceptable), for hexadecimal p (or P) is used: <code>-2.22e-21</code> <code>-0x21.93p-10</code> </p>
<p>It is possible to type a floating point by adding a suffix:</p>
<table>
<thead>
<tr>
<th>Suffix</th>
<th align="right">type</th>
</tr>
</thead>
<tbody>
<tr>
<td>f16</td>
<td align="right">float16</td>
</tr>
<tr>
<td>f32 <em>or f</em></td>
<td align="right">float</td>
</tr>
<tr>
<td>f64</td>
<td align="right">double</td>
</tr>
<tr>
<td>f128</td>
<td align="right">float128</td>
</tr>
</tbody>
</table>
<h3 id="c-compatibility">C compatibility</h3>
<p>For C compatibility the following types are also defined in std::core::cinterop</p>
<table>
<thead>
<tr>
<th>Name</th>
<th align="right">c type</th>
</tr>
</thead>
<tbody>
<tr>
<td>CChar</td>
<td align="right">char</td>
</tr>
<tr>
<td>CShort</td>
<td align="right">short int</td>
</tr>
<tr>
<td>CUShort</td>
<td align="right">unsigned short int</td>
</tr>
<tr>
<td>CInt</td>
<td align="right">int</td>
</tr>
<tr>
<td>CUInt</td>
<td align="right">unsigned int</td>
</tr>
<tr>
<td>CLong</td>
<td align="right">long int</td>
</tr>
<tr>
<td>CULong</td>
<td align="right">unsigned long int</td>
</tr>
<tr>
<td>CLongLong</td>
<td align="right">long long</td>
</tr>
<tr>
<td>CULongLong</td>
<td align="right">unsigned long long</td>
</tr>
<tr>
<td>CFloat</td>
<td align="right">float</td>
</tr>
<tr>
<td>CDouble</td>
<td align="right">double</td>
</tr>
<tr>
<td>CLongDouble</td>
<td align="right">long double</td>
</tr>
</tbody>
</table>
<p>Note that signed C char and unsigned char will correspond to <code>ichar</code> and <code>char</code>. <code>CChar</code> is only available to match the default signedness of <code>char</code> on the platform.</p>
<h2 id="other-built-in-types">Other built-in types</h2>
<h3 id="pointer-types">Pointer types</h3>
<p>Pointers mirror C: <code>Foo*</code> is a pointer to a <code>Foo</code>, while <code>Foo**</code> is a pointer to a pointer of Foo.</p>
<h3 id="the-typeid-type">The <code>typeid</code> type</h3>
<p>The <code>typeid</code> can hold a runtime identifier for a type. Using <code>&lt;typename&gt;.typeid</code> a type may be converted to its unique runtime id, 
e.g. <code>typeid a = Foo.typeid;</code>. This value is pointer-sized.</p>
<h3 id="the-variant-type">The <code>variant</code> type</h3>
<p>C3 contains a built-in variant type, which is essentially struct containing a <code>typeid</code> plus a <code>void*</code> pointer to a value.
It is possible to cast the variant type to any pointer type, which will return <code>null</code> if the types don't match,
or the pointer value otherwise.</p>
<pre><code>int x;
variant y = &amp;x;
double *z = (double*)y; // Returns null
int* w = (int*)x; // Returns the pointer to x
</code></pre>
<p>Switching over the variant type is another method to unwrap the pointer inside:</p>
<pre><code>fn void test(variant z)
{
    // Unwrapping switch
    switch (z)
    {
        case int: 
            // z is unwrapped to int* here
        case double:
            // z is unwrapped to double* here
    }
    // Assignment switch
    switch (y = z)
    {
        case int:
            // y is int* here
    }
    // Direct unwrapping to a value is also possible:
    switch (w = *z)
    {
        case int:
            // w is int here
    }
}
</code></pre>
<p><code>variant.type</code> returns the underlying pointee typeid of the contained value. <code>variant.ptr</code> returns 
the raw <code>void*</code> pointer.</p>
<h3 id="array-types">Array types</h3>
<p>Arrays are indicated by <code>[size]</code> after the type, e.g. <code>int[4]</code>. Subarrays use the <code>type[]</code>. For initialization the wildcard <code>type[*]</code> can be used to infer the size
from the initializer. See the chapter on <a href="../arrays">arrays</a>.</p>
<h3 id="vector-types">Vector types</h3>
<p>Vectors use <code>[&lt;size&gt;]</code> after the type, e.g. <code>float[&lt;3&gt;]</code>, with the restriction that vectors may only form out
of integers, floats and booleans. Similar to vectors, wildcard can be used to infer the size of a vector: <code>int[&lt;*&gt;] a = { 1, 2 }</code>.</p>
<p><em>Note: C3 will support scaled vectors using the syntax <code>float[&lt;&gt;]</code>, but this is currently not implemented.</em></p>
<h2 id="types-created-using-defined">Types created using <code>defined</code></h2>
<h3 id="typedef">"typedef"</h3>
<p>Like in C, C3 has a "typedef" construct, <code>define &lt;typename&gt; = &lt;type&gt;</code></p>
<pre><code>define Int32 = int;
define Vector2 = float[&lt;2&gt;];

...

Int32 a = 1;
int b = a;
</code></pre>
<h3 id="function-pointer-types">Function pointer types</h3>
<p>Function pointers are always used through a <code>define</code>:</p>
<pre><code>define Callback = fn void(int value);
Callback callback = &amp;test;

fn void test(int a) { ... }
</code></pre>
<p>To form a function pointer, write a normal function declaration but skipping the function name. <code>fn int foo(double x)</code> -&gt;
<code>fn int(double x)</code>.</p>
<p>Function pointers can have default arguments, e.g. <code>define Callback = fn void(int value = 0)</code> but default arguments
and parameter names are not taken into account when determining function pointer assignability:</p>
<pre><code>define Callback = fn void(int value = 1);
fn void test(int a = 0) { ... }

Callback callback = &amp;main; // Ok

fn void main()
{
  callback(); // Works, same as test(0);
  test(); // Works, same as test(1);
  callback(.value = 3); // Works, same as test(3)
  test(.a = 4); // Works, same as test(4)
  // callback(.a = 3); ERROR!
}
</code></pre>
<h3 id="distinct-types">Distinct types</h3>
<p>Distinct types is a kind of typedef which creates a new type that has the same properties as the original type
but is - as the name suggests - distinct from it. It cannot implicitly convert into the other type. A distinct type
is created by adding <code>distinct</code> before the type name in a "define": <code>define &lt;typename&gt; = distinct &lt;type&gt;</code></p>
<pre><code>define MyId = distinct int;
fn void* get_by_id(MyId id) { ... }

fn void test(MyId id)
{
  void* val = get_by_id(id); // Ok
  void* val2 = get_by_id(1); // Literals convert implicitly
  int a = 1;
  // void* val3 = get_by_id(a); // ERROR expected a MyId
  void* val4 = get_by_id((MyId)a); // Works
  // a = id; // ERROR can't assign 'MyId' to 'int'
}
</code></pre>
<h3 id="generic-types">Generic types</h3>
<p>Similar to function pointers, generic types are only available using <code>define</code>:</p>
<pre><code>import generic_list; // Contains the generic MyList

struct Foo { int x; }

define IntMyList = generic_list::MyList&lt;int&gt;;
define FooMyList = generic_list::MyList&lt;Foo&gt;;
</code></pre>
<p>Read more about generic types on <a href="../generics">the page about generics</a>.</p>
<h2 id="enum">Enum</h2>
<p>Enum (enumerated) types use the following syntax:</p>
<pre><code>enum State : int 
{
  PENDING,
  RUNNING,
  TERMINATED
}
</code></pre>
<p>Enum constants are namespaces by default, just like C++'s class enums. So accessing the enums above would for example use <code>State.PENDING</code> rather than <code>PENDING</code>.</p>
<h3 id="enum-type-inference">Enum type inference</h3>
<p>When an enum is used in where the type can be inferred, like in case-clauses or in variable assignment, it is allowed to drop the enum name:</p>
<pre><code>State foo = PENDING; // State.PENDING is inferred.
switch (foo)
{
  case RUNNING: // State.RUNNING is inferred
    ...
  default:
    ...
}

fn void test(State s) { ... }

...

test(RUNNING); // State.RUNNING is inferred
</code></pre>
<p>In the case that it collides with a global in the same scope, it needs the qualifier:</p>
<pre><code>module test;

fn void testState(State s) { ... }

const State RUNNING = State.TERMINATED; // Don't do this!

...

test(RUNNING); // Ambiguous
test(test::RUNNING); // Uses global.
test(State.RUNNING); // Uses enum constant.
</code></pre>
<h3 id="enum-associated-values">Enum associated values</h3>
<p>It is possible to associate each enum value with a static value.</p>
<pre><code>enum State : int (String state_desc, bool active) 
{
    PENDING("pending start", false),
    RUNNING("running", true),
    TERMINATED("ended", false)
}

...

State s = get_state();

io::printfn("Currently the process is %s", s.state_desc);
if (s.active) do_something();
</code></pre>
<h2 id="faults">Faults</h2>
<p><code>fault</code> defines a set of optional result values, that are similar to enums, but are used for 
optional returns.</p>
<pre><code>fault IOResult
{
  IO_ERROR,
  PARSE_ERROR
}

fault MapResult
{
  NOT_FOUND
}
</code></pre>
<p>Like the typeid, the constants are pointer sized and each value is globally unique, even when 
compared to other faults. For example the underlying value of <code>MapResult.NOT_FOUND</code> is guaranteed
to be different from <code>IOResult.IO_ERROR</code>. This is true even if they are separately compiled.</p>
<p>A fault may be stored as a normal value, but is also unique in that it may be passed
as the optional result value using the <code>!</code> suffix operator.</p>
<h2 id="optional-result-types">Optional Result Types</h2>
<p>An <em>optional result type</em> is created by taking a type and appending <code>!</code>. 
An optional result type is a tagged union containing either the <em>expected result</em> or <em>an optional result value</em> 
(which is a fault).</p>
<pre><code>int! i;
i = 5; // Assigning a real value to i.
i = IOResult.IO_ERROR!; // Assigning an optional result to i.
</code></pre>
<p>Only variables and return variables may be optionals. Function and macro parameters may not be optionals.</p>
<pre><code>fn Foo*! getFoo() { ... } // Ok!
fn void processFoo(Foo*! f) { ... } // Error
int! x = 0; // Ok!
</code></pre>
<p>Read more about the optional types on the page about <a href="../errorhandling">error handling</a>.</p>
<h2 id="struct-types">Struct types</h2>
<p>Structs are always named:</p>
<pre><code>struct Person  
{
    char age;
    String name;
}
</code></pre>
<p>A struct's members may be accessed using dot notation, even for pointers to structs.</p>
<pre><code>Person p;
p.age = 21;
p.name = "John Doe";

libc::printf("%s is %d years old.", p.age, p.name);

Person* pPtr = &amp;p;
pPtr.age = 20; // Ok!

libc::printf("%s is %d years old.", pPtr.age, pPtr.name);
</code></pre>
<p>(One might wonder whether it's possible to take a <code>Person**</code> and use dot access. – It's not allowed, only one level of dereference is done.)</p>
<p>To change alignment and packing, optional <a href="../attributes">attributes</a> such as <code>@packed</code> may be used.</p>
<h2 id="struct-subtyping">Struct subtyping</h2>
<p>C3 allows creating struct subtypes using <code>inline</code>:</p>
<pre><code>struct ImportantPerson 
{
    inline Person person;
    String title;
}

fn void printPerson(Person p)
{
    libc::printf("%s is %d years old.", p.age, p.name);
}


ImportantPerson important_person;
important_person.age = 25;
important_person.name = "Jane Doe";
important_person.title = "Rockstar";
printPerson(important_person); // Only the first part of the struct is copied.
</code></pre>
<h2 id="union-types">Union types</h2>
<p>Union types are defined just like structs and are fully compatible with C.</p>
<pre><code>union Integral  
{
    byte as_byte;
    short as_short;
    int as_int;
    long as_long;
}
</code></pre>
<p>As usual unions are used to hold one of many possible values:</p>
<pre><code>Integral i;
i.as_byte = 40; // Setting the active member to as_byte

i.as_int = 500; // Changing the active member to as_int

// Undefined behaviour: as_byte is not the active member, 
// so this will probably print garbage.
libc::printf("%d\n", i.as_byte);
</code></pre>
<p>Note that unions only take up as much space as their largest member, so <code>Integral.sizeof</code> is equivalent to <code>long.sizeof</code>.</p>
<h2 id="nested-sub-structs-unions">Nested sub-structs / unions</h2>
<p>Just like in C99 and later, nested anonymous sub-structs / unions are allowed. Note that
the placement of struct / union names is different to match the difference in declaration.</p>
<pre><code>struct Person  
{
    char age;
    String name;
    union 
    {
        int employee_nr;
        uint other_nr;
    }
    union subname 
    {
        bool b;
        Callback cb;
    }
}
</code></pre>
<h2 id="bitstructs">Bitstructs</h2>
<p>Bitstructs allows storing fields in a specific bit layout. A bitstruct may only contain
integer types and booleans, in most other respects it works like a struct.</p>
<p>The main differences is that the bitstruct has a <em>backing type</em> and each field
has a specific bit range. In addition it's not possible <em>to take the address</em> of a
bitstruct field.</p>
<pre><code>bitstruct Foo : char
{
    int a : 0..2;
    int b : 4..6;
    bool c : 7;
}

...

Foo f;
f.a = 2;
char x = (char)f;
io::printfn("%d", (char)f); // prints 2
f.b = 1;
io::printfn("%d", (char)f); // prints 18 
f.c = true;
io::printfn("%d", (char)f); // prints 146
</code></pre>
<p>The bitstruct will follow the endianness of the underlying type:</p>
<pre><code>bitstruct Test : uint
{
    ushort a : 0..15;
    ushort b : 16..31;
}

...

Test t;
t.a = 0xABCD;
t.b = 0x789A;
char* c = (char*)&amp;t;
io::printfn("%X", (uint)t); // Prints 789AABCD
for (int i = 0; i &lt; 4; i++) io::printf("%X", c[i]); // Prints CDAB9A78
io::println();
</code></pre>
<p>It is however possible to pick a different endianness, in which case the entire representation
will internally assume big endian layout:</p>
<pre><code>bitstruct Test : uint @bigendian
{
    ushort a : 0..15;
    ushort b : 16..31;
}
</code></pre>
<p>In this case the same example yields <code>CDAB9A78</code> and <code>789AABCD</code> respectively.</p>
<p>Bitstruct backing types may be integers or char arrays. The difference in layout is somewhat subtle:</p>
<pre><code>bitstruct Test1 : char[4]
{
    ushort a : 0..15;
    ushort b : 16..31;
}
bitstruct Test2 : char[4] @bigendian
{
    ushort a : 0..15;
    ushort b : 16..31;
}

...

Test1 t1;
Test2 t2;
t1.a = t2.a = 0xABCD;
t1.b = t2.b = 0x789A;
char* c = (char*)&amp;t1;
for (int i = 0; i &lt; 4; i++) io::printf("%X", c[i]); // Prints CDAB9A78 on x86
io::println();
c = (char*)&amp;t2;
for (int i = 0; i &lt; 4; i++) io::printf("%X", c[i]); // Prints ABCD789A
io::println();
</code></pre>
<p>Bitstructs can be made to have ovelapping bit fields. This is useful when modelling
a layout which has multiple different layouts depending on flag bits:</p>
<pre><code>bitstruct Foo : char @overlap
{
    int a : 2..5;
    int b : 1..3; // Only valid due to the @overlap attribute
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../define/" class="btn btn-neutral float-right" title="Define">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../modules/" class="btn btn-neutral" title="Modules"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../modules/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../define/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
