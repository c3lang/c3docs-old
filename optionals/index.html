<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Optionals and error handling - C3 Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Optionals and error handling";
    var mkdocs_page_input_path = "optionals.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/ebnf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C3 Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">About C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Installing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../setup/">Setup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../firstproject/">Your first project</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../primer/">A quick primer on C3</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../changesfromc/">Changes from C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compare/">Comparisons with other languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">Types</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../define/">Define</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../arrays/">Arrays</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../statements/">Statements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../expressions/">Expressions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Optionals and error handling</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#what-is-an-optional">What is an Optional?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#optional-execution">Optional execution</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#optional-unwrapping">Optional unwrapping</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#if-try">If-try</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#if-catch">If-catch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#implicit-unwrapping-with-if-catch">Implicit unwrapping with if-catch.</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#getting-the-fault-without-unwrapping">Getting the fault without unwrapping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#if-catch-switching">If-catch switching</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#testing-for-a-result-without-unwrapping">Testing for a result without unwrapping</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fault-and-anyfault">fault and anyfault</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#setting-the-result-and-the-fault">Setting the result and the fault</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rethrow-or-else-and-force-unwrap">Rethrow, or-else and force unwrap</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#rethrow">Rethrow</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#or-else">Or-else</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#force-unwrap">Force unwrap</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#implicit-void-conversions">Implicit void! conversions</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#basic-usage-with-immediate-error-handling">Basic usage with immediate error handling</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#composability-of-calls">Composability of calls</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#returning-a-fault">Returning a fault</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#calling-a-function-automatically-returning-any-optional-result">Calling a function automatically returning any optional result</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#force-unwrapping-to-panic-on-fault">Force unwrapping to panic on fault</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#catching-faults-to-implicitly-unwrap">Catching faults to implicitly unwrap</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#only-run-if-there-is-no-fault">Only run if there is no fault</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#catching-and-switch-on-fault">Catching and switch on fault</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#default-values-using-or-else">Default values using or-else</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get-the-fault-from-an-optional-without-if-catch">Get the fault from an optional without if-catch</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#test-if-something-has-a-value-without-if-try">Test if something has a value without if-try</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#some-common-techniques">Some common techniques</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#catch-and-return-another-error">Catch and return another error</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#using-void-as-a-boolean">Using void! as a boolean</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#interfacing-with-c">Interfacing with C</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../compiletime/">Compile time evaluation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../contracts/">Contracts</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../generics/">Generics</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../reflection/">Reflection</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../operators/">Operator overloading</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../undefinedbehaviour/">Undefined behaviour</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../conversion/">Conversions</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../precedence/">Precedence</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../builtins/">Builtins</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../libraries/">Libraries</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../standard_library/">Standard Library</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ideas/">Crazy ideas</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../naming/">Naming rules</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../comments/">Comments & Docs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../attributes/">Attributes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../asm/">Inline asm</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cinterop/">C Interop</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../syntax/">Grammar</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../sample/">More code examples</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../specification/">Specification</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Build system</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../buildintro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../project/">Project Structure</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../buildcommands/">Commands</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Development</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../contribute/">Contribute</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../changes/">Changes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../rejectedideas/">Rejected ideas</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C3 Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Optionals and error handling</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="optionals-and-error-handling">Optionals and error handling</h1>
<p>Optionals in C3 work differently from other languages:</p>
<ol>
<li>It is similar to a "Result" type in capabilities.</li>
<li>It is not quite a type: it can be used for variable and return values - but not for parameters or struct member types.</li>
<li>It "cascades" the optional-ness of an expression, somewhat reminiscent of the "flatmap" operation.</li>
<li>A function called with an Optional is only invoked if it has an actual value.</li>
</ol>
<h2 id="what-is-an-optional">What is an Optional?</h2>
<p>In C3 it is either:</p>
<ol>
<li>A variable that works as a union between a <code>fault</code> value and an actual value, we call this latter the "result".</li>
<li>A return value that is either a <code>fault</code> or a result.</li>
</ol>
<p>We can construct an Optional by adding the <code>!</code> suffix to a type:</p>
<pre><code class="language-c">int! a; // An optional value with the result type of &quot;int&quot;

fn int! foo() // A function returning an optional value with the result type of &quot;int&quot;
{
  ...
}  
</code></pre>
<p>It is not possible to create an Optional of an Optional (so for example <code>int!!</code> is never valid).</p>
<p><em>Using</em> a variable or return with an Optional type yields an optional:</p>
<pre><code>int! a = ...
fn int! foo() { ... }

double! x = a * 3.14159;
double! y = foo() * 0.3333333333;
double! z = x * y;
</code></pre>
<p>Similar to basic operations it's possible to use an Optional value as a call parameter. The return value then becomes Optional</p>
<pre><code>int! a = ...
fn double bar(int x) { ... }

// "bar" can be called because the result type of the Optional is "int"
// but the return value will become Optional:
double! x = bar(a);
</code></pre>
<h2 id="optional-execution">Optional execution</h2>
<p>The most important feature of Optionals is how it will only optionally execute
operations. Given a call with the arguments a0, a1, ... the call will only 
be invoked if all of the arguments evaluate to real values.</p>
<pre><code>int! a = 1;
int! b = MyResult.FOO?;

// "baz" called, because "a" is has a result. 
int! z = baz(a, a);  // same as z = bar(1, 1)

// "baz" is not called, because "b" evaluates to a fault
int! y = baz(a, b);

// Due to evaluation ordering "abc" is called, but not "def" nor "baz":
int! x = baz(abc(a), def(b));

// Due to evaluation ordering none of "abc", "def" or "baz" is called:
int! x2 = baz(def(b), abc(a));
</code></pre>
<p>We can think of the above example <code>int! x = baz(a, b)</code> as the following:</p>
<ol>
<li>Evaluate the first argument.</li>
<li>If it is a <code>fault</code> then we're done, set <code>x</code> to this fault.</li>
<li>Evaluate the second argument.</li>
<li>If it is a <code>fault</code> then we're done, set <code>x</code> to this fault.</li>
<li>Execute <code>baz</code> with the result values from the arguments.</li>
</ol>
<p>Optional execution allows us to avoid dealing with intermediary errors, we can simply
collect them together:</p>
<p><code>int! x = foo_return_optional(other_return_optional(optional_value))</code></p>
<h2 id="optional-unwrapping">Optional unwrapping</h2>
<p>It's not possible to assign an Optional to a non-optional type:</p>
<pre><code class="language-c">int! a = ...

int b = a; // &lt;- ERROR, can't assign &quot;int!&quot; to &quot;int&quot;
</code></pre>
<p>To assign it we have two options, <code>if-try</code> and implicit unwrap.</p>
<h3 id="if-try">If-try</h3>
<p>If-try tests an Optional and executes the "then" part if the value is contains a result.</p>
<pre><code>int! a = ...;
int b;

if (try int x = a) 
{
    // This part only executes if "a" has a result.
    b = x; 
}
</code></pre>
<p>There are abbreviated variants of <code>if-try</code>:</p>
<pre><code>if (try x = a) { ... } // Infer type of "x"
if (try a) { ... } // Unwrap "a" inside of this context.
</code></pre>
<p>It is possible to add conditions to an <code>if-try</code> but they must be joined with <code>&amp;&amp;</code>
"or" (i.e. <code>||</code>) is not allowed:</p>
<pre><code>if (try a &amp;&amp; try z &amp;&amp; a &gt; z)
{
    // Only executes if a and z have results 
    // *and* a &gt; z
    ...
}

// if (try a || try z) { ... } &lt;- ERROR!
</code></pre>
<h3 id="if-catch">If-catch</h3>
<p>If-catch works the other way and only executes if the Optional is a fault:</p>
<pre><code>if (catch anyfault f = a) 
{
    // Handle the fault
}
</code></pre>
<p>Just like for if-try there are abbreviated variants:</p>
<pre><code>if (catch f = a) { ... } // "f" has the type of "anyfault"
if (catch a) { ... } // Discards the actual fault value
</code></pre>
<p>It is possible to catch multiple errors by grouping them with <code>,</code>:</p>
<pre><code>if (catch f = a, b, foo()) 
{
    // Returns the fault from a, b or foo()
    // trying each in order.
    // foo() is only called if neight a nor b has a fault.
}
</code></pre>
<h3 id="implicit-unwrapping-with-if-catch">Implicit unwrapping with if-catch.</h3>
<p>If an <code>if-catch</code> returns or jumps out of the current scope in some way, then
the variable becomes implicit unwrapped to its result type in that scope:</p>
<pre><code>int! a = foo_may_error();

if (catch a)
{
    return;
}

// a is now considered a plain int:
int b = a;
</code></pre>
<h3 id="getting-the-fault-without-unwrapping">Getting the fault without unwrapping</h3>
<p>If-catch is not necessary in order to get the underlying fault from any Optional. Instead the macro <code>@catchof</code> 
may be used.</p>
<pre><code>int! a = ...

anyfault f = @catchof(a);

if (!f)
{
    // No error!
}
</code></pre>
<h3 id="if-catch-switching">If-catch switching</h3>
<p>If-catch can also immediately switch on the fault value:</p>
<pre><code>if (catch a) 
{
    case MyResult.FOO:
        ...
    case IoError.NO_SUCH_FILE:
        ...
    case IoError.FILE_NOT_DIR:
        ...
    default:
        ...
}
</code></pre>
<p>The above being equivalent to:</p>
<pre><code>if (catch f = a) 
{
    switch (f)
    {
        case MyResult.FOO:
            ...
        case IoError.NO_SUCH_FILE:
            ...
        case IoError.FILE_NOT_DIR:
            ...
        default:
            ...
    }
}
</code></pre>
<h3 id="testing-for-a-result-without-unwrapping">Testing for a result without unwrapping</h3>
<p>The <code>@ok</code> macro will return <code>true</code> is an Optional is a result and <code>false</code>
it is a fault. Functionally it is equivalent to <code>!@catchof</code></p>
<pre><code>int! a = ...

bool was_ok = @ok(a);
assert(was_ok == !@catchof(a));
</code></pre>
<h2 id="fault-and-anyfault"><code>fault</code> and <code>anyfault</code></h2>
<p>Faults are defined similar to simple enums:</p>
<pre><code>fault MyResult
{
    SOMETHING_HAPPENED,
    UNEXPECTED_ERROR,
}
</code></pre>
<p>The union of all of such types is <code>anyfault</code>:</p>
<pre><code>MyResult foo = MyResult.UNEXPECTED_ERROR;

anyfault x = foo;
x = IoError.NO_SUCH_FILE; // Also ok
</code></pre>
<h2 id="setting-the-result-and-the-fault">Setting the <code>result</code> and the <code>fault</code></h2>
<p>To set the <code>result</code> of an Optional, use regular assignment, and
to set the <code>fault</code> <code>?</code> suffix operator.</p>
<pre><code>int! a = 1;
int! b = MyResult.UNEXPECTED_ERROR?; // &lt;- '?' sets the fault

MyResult foo = MyResult.UNEXPECTED_ERROR;
anyfault bar = IoError.NO_SUCH_FILE;

int! c = foo?; // c has the fault MyResult.UNEXPECTED_ERROR
int! d = bar?; // d has the fault IoError.NO_SUCH_FILE?
</code></pre>
<h2 id="rethrow-or-else-and-force-unwrap">Rethrow, or-else and force unwrap</h2>
<p>Three helper operators are provided for working with Optionals:
rethrow <code>!</code>, or-else <code>??</code> and force unwrap <code>!!</code>.</p>
<h3 id="rethrow">Rethrow</h3>
<p>Sometimes the optional fault needs to be propagated upwards, here is 
an example:</p>
<pre><code>int! a = foo_may_error();

if (catch f = a)
{
    return f?; // Pass the fault upwards.
}
</code></pre>
<p>To simplify this the rethrow operator <code>!</code> can be used:</p>
<pre><code>// Equivalent to the code above.
int! a = foo_may_error()!;
</code></pre>
<p>Because the rethrow operator automatically returns on a fault, the return value
turns into its result. In the above example the type of <code>foo_may_error()!</code> becomes <code>int</code>:</p>
<pre><code>int b = foo_may_error()!; // This works
</code></pre>
<h3 id="or-else">Or-else</h3>
<p>Sometimes we have this situation:</p>
<pre><code>int! a_temp = foo_may_error();
int a;
if (try a_temp)
{   
    a = a_temp;
}
else
{
    a = -1;
}
</code></pre>
<p>The or-else operator <code>??</code> works similar to <code>?:</code> allowing you to do this in a single expression:</p>
<pre><code>// Equivalent to the above
int a = foo_may_error() ?? -1;
</code></pre>
<h3 id="force-unwrap">Force unwrap</h3>
<p>Sometimes a <code>fault</code> is completely unexpected, and we want to assert if 
it happens:</p>
<pre><code>int! a = foo_may_error();
if (catch f = a) 
{
    unreachable("Unexpected fault %s", f);
}
... use "a" as int here ...
</code></pre>
<p>The force unwrap operator <code>!!</code> allows us to express this similar to rethrow and or-else:</p>
<pre><code>int a = foo_may_error()!!;
</code></pre>
<h2 id="implicit-void-conversions">Implicit void! conversions</h2>
<p>The <code>void!</code> type has no possible representation as a variable. For this reason <code>void!</code> may
only be a return type. However, <code>void!</code> will always implicitly convert into an <code>anyfault</code>:</p>
<pre><code>fn void! test() { ... }

anyfault f = test();
// The above is has the same meaning as:
anyfault g = @catchof(test());
</code></pre>
<h2 id="examples">Examples</h2>
<h4 id="basic-usage-with-immediate-error-handling">Basic usage with immediate error handling</h4>
<pre><code>// Open a file, we will get an optional result:
// Either a File* or an error.
File*! file = file::open("foo.txt");

// We can extract the optional result value using "catch"
if (catch f = file)
{
    // Might print "Error was FILE_NOT_FOUND"
    io::printfn("Error was %s", f.name());

    // Might print "Error code: 931938210"
    io::printfn("Error code: %d", (uptr)err); 
    return;
}

// Because of implicit unwrapping, the type of
// `file` is File* here.
</code></pre>
<p>We can also execute just in case of success:</p>
<pre><code>File*! file2 = file::open("bar.txt");

// Only true if there is an expected result.
if (try file2)
{
    // Inside here file2 is a regular File*
}
</code></pre>
<h4 id="composability-of-calls">Composability of calls</h4>
<pre><code>fn int! foo_may_error() { ... }
fn int mult(int i) { ... }
fn int! save(int i) { ... }

fn void test()
(
    // "mult" is only called if "fooMayError()"
    // returns a non optional result.
    int! j = mult(foo_may_error());

    int! k = save(mult(foo_may_error()));
    if (catch f = k)
    {
        // The fault may be from foo_may_error
        // or save!
    }    
)
</code></pre>
<h4 id="returning-a-fault">Returning a fault</h4>
<p>Returning a fault looks like a normal return but with the <code>?</code></p>
<pre><code>fn void! find_file()
{
    if (file::exists(&quot;foo.txt&quot;)) return IoError.FILE_NOT_FOUND?;
    /* ... */
}
</code></pre>
<h4 id="calling-a-function-automatically-returning-any-optional-result">Calling a function automatically returning any optional result</h4>
<p>The <code>!</code> suffix will create an implicit return on a fault.</p>
<pre><code>fn void! find_file_and_test()
{
    find_file()!;
    // Implictly:
    // if (catch f = find_file()) return f?;
}
</code></pre>
<h4 id="force-unwrapping-to-panic-on-fault">Force unwrapping to panic on fault</h4>
<p>The <code>!!</code> will issue a panic if there is a fault.</p>
<pre><code>fn void find_file_and_test()
{
    find_file()!!;
    // Implictly:
    // if (catch find_file()) unreachable(&quot;Unexpected error&quot;);
}
</code></pre>
<h4 id="catching-faults-to-implicitly-unwrap">Catching faults to implicitly unwrap</h4>
<p>Catching faults and then exiting the scope will implicitly unwrap the
variable:</p>
<pre><code>fn void find_file_and_no_fault()
{
    File*! res = find_file();    
    if (catch res)
    {
        io::printn("An error occurred!");
        // Jump required for unwrapping!
        return;
    }
    // res is implicitly unwrapped here.
    // and have an effective type of File*.
}
</code></pre>
<h4 id="only-run-if-there-is-no-fault">Only run if there is no fault</h4>
<pre><code>fn void do_something_to_file()
{
    void! res = find_file();    
    if (try res)
    {
        io::printn(&quot;I found the file&quot;);
    }
}
</code></pre>
<h4 id="catching-and-switch-on-fault">Catching and switch on fault</h4>
<pre><code>fn void! find_file_and_parse2()
{
    if (catch f = find_file_and_parse())
    {
        case IOError.FILE_NOT_FOUND:
            io::printn("Error loading the file!");
        default:
            return f?;
    }
}
</code></pre>
<h4 id="default-values-using-or-else">Default values using or-else</h4>
<pre><code>fn int get_int()
{
    return get_int_number_or_fail() ?? -1;
}
</code></pre>
<h4 id="get-the-fault-from-an-optional-without-if-catch">Get the fault from an optional without <code>if-catch</code></h4>
<pre><code>fn void test_catch()
{
    int! i = get_something();
    anyfault maybe_fault = @catchof(i);
    if (maybe_fault)
    {
        // Do something with the fault
    }
}
</code></pre>
<h4 id="test-if-something-has-a-value-without-if-try">Test if something has a value without <code>if-try</code></h4>
<pre><code>fn void test_something()
{
    int! i = try_it();
    bool worked = @ok(i);
    if (worked)
    {
        io::printn("Horray! It worked.");
    }
}
</code></pre>
<h3 id="some-common-techniques">Some common techniques</h3>
<p>Here follows some common techniques using optional values.</p>
<h4 id="catch-and-return-another-error">Catch and return another error</h4>
<p>In this case we don't want to return the underlying fault, but instead return out own replacement error.</p>
<pre><code>fn void! return_own()
{
    int! i = try_something() ?? OurError.SOMETHING_FAILED?;
    .. do things ..
}

fn void! return_own_rethrow()
{
    int i = try_something() ?? OurError.SOMETHING_FAILED?!; // Cause immediate rethrow
    .. do things ..
}
</code></pre>
<h4 id="using-void-as-a-boolean">Using void! as a boolean</h4>
<p>A common pattern in C is to use a boolean result to indicate success. <code>void!</code> can be used
in a similar way:</p>
<pre><code>// C
bool store_foo(Foo* f)
{
    if (!foo_repository_is_valid()) return false;
    return foo_repo_store_foo(f);
}

void test()
{
    Foo* f = foo_create();
    if (store_foo(f)) 
    {
        puts("Storage worked");
        return;
    }
    ...
}


// C3
fn void! store_foo(Foo* f)
{
    if (!foo_repository_is_valid()) return FooFaults.INVALID_REPO?;
    return foo_repo_store_foo(f);
}

fn void test()
{
    Foo* f = foo_create();
    if (@ok(store_foo(f))) 
    {
        io::printn("Storage worked");
        return;
    }
    ...
}
</code></pre>
<h2 id="interfacing-with-c">Interfacing with C</h2>
<p>For C the interface to C3, the fault is returned as the regular return while the result
is passed by reference:</p>
<p>C3 code:</p>
<pre><code>fn int! get_value();
</code></pre>
<p>Corresponding C code:</p>
<pre><code>c3fault_t get_value(int *value_ref);
</code></pre>
<p>The <code>c3fault_t</code> is guaranteed to be a pointer sized value.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../compiletime/" class="btn btn-neutral float-right" title="Compile time evaluation">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../variables/" class="btn btn-neutral" title="Variables"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../variables/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../compiletime/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
